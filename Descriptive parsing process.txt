Proposition No.		0123456789ABCEF
	1				~(A|(B^~C))>D
	2				~(A|(B^(~C)))>D


// Prototype of the $group array
$group[{startindex}] = 
	[
		'start'			=>	integer, // Character index
		'end'			=>	integer, // Character index
		'finalOp'		=>	char, // Logical Operator
		'evalLocation'	=>	integer // Character index
	];
// Prototype of the $evaluated array
$evaluated[{characterindex}] = bool // Boolean value

General process...

*. Strip White Spaces
*. Explode string into chars array ($propositionChars)
*. Make sure all characters are valid {validChars}
*. Check to make sure first character is valid {firstCharCheck}
*. Verify parenthesis match {parenCheck}
*. Go through $propositionChars, and for each symbol [A, B, C, etc], assign the actual boolean value for the iteration ($propositionChars[$idx] = TRUE | FALSE)
*. Reset point of $propositionChars
*. foreach($propositionChars as $idx => $char){propProcess} (Probably won't want to use a foreach though since we'll be moving the pointer around)

{validChars}
Iterate through $propositionChars and ensure they are either a valid symbol, logical operator, or parenthesis

{firstCharCheck}
Make sure that The first character in the string is either a symbol, negation '~', or left parethesis '(' otherwise throw error and exit

{parenCheck}
Iterate through $propositionChars. For each '(' then $parenCount++, for each ')' then $parentCount--. Check after each character check that $parenCount >= 0 or throw error and exit. After the iteration is complete, if $parenCount != 0 throw an error and exit

{propProcess}
1. If $char === '(' then mark location ($group[$idx]['start'] = $idx) and iterate to next character
2. If $char === BOOL (This is where the === is critical, to actually check against a boolean, not another type), do a quick check to make sure it's not immediately followed by another BOOL, '~', or '('. If so, throw error and exit. If not, iterate to next
3. If $char in [$logicalOperators] then {logicOp[$char]}
4. If $char === ')' then set the pointer of $group to the last index, set $group[key($group)]['end'] = $idx, and perform post-group operations as determined by {postGroup}

{logicOp['~']}
1. If next $char === BOOL then $evaluated[$idx] = !$char
2. If next $char === logical operator or ')', throw error and exit (I'll worry about double negation later)
3. If next $char === '(' then set $group[$idx+1]['finalOp'] = '~', set $group[$idx+1]['evalLocation'] = $idx and go to the next character

{logicOp['|']}
1. If previous $char === '(' throw error and exit
2. If next $char === logical operator or ')' throw error and exit (Implies negation will need to be in group)
3. If previous $char === ')' then pull the value of $evaluated[end($group)['evalLocation']] as the first boolean to compare, pop($group) since that value has served its purpose
4. If previous $char === BOOL then that will be the first boolean to compare
5. If next $char === BOOL then that will be the next boolean to compare
6. If next $char === '(' then set $group[$idx+1]['finalOp'] = '|' and go to the next character

{logicOp['^']}
1. If previous $char === '(' throw error and exit
2. If next $char === logical operator or ')' throw error and exit (Implies negation will need to be in group)
3. If previous $char === ')' then pull the value of $evaluated[end($group)['evalLocation']] as the first boolean to compare, pop($group) since that value has served its purpose
4. If previous $char === BOOL then that will be the first boolean to compare
5. If next $char === BOOL then that will be the next boolean to compare
6. If next $char === '(' then set $group[$idx+1]['finalOp'] = '^' and go to the next character

{logicOp['>']}
1. If previous $char === '(' throw error and exit
2. If next $char === logical operator or ')' throw error and exit (Implies negation will need to be in group)
3. If previous $char === ')' then pull the value of $evaluated[end($group)['evalLocation']] as the first boolean to compare, pop($group) since that value has served its purpose
4. If previous $char === BOOL then that will be the first boolean to compare
5. If next $char === BOOL then that will be the next boolean to compare
6. If next $char === '(' then set $group[$idx+1]['finalOp'] = '>' and go to the next character





/* -----------Walk through based on proposition 1 (all values false)--------------- */
$propositionChars	Process
	[0]					0. Character index @ 0.
	[0]					1. '~' encountered. Next char === '('. $group[1]['finalOp'] = '~'; $group[1]['evalLocation'] = 0; Next index.
	[1]					2. '(' encountered. $group[1]['start'] = 1; Next index.
	[2]					3. FALSE encountered. Next character is not BOOLEAN or '(' or '~'. Next index.
	[3]					4. '|' encountered. Previous char === FALSE. Next char === '('. $group[4]['finalOp'] = '|'; Next index.
	[4]					5. '(' encountered. $group[4]['start'] = 4; Next index.
	[5]					6. FALSE encountered. Next character is not BOOLEAN or '(' or '~'. Next index.
	[6]					7. '^' encountered. Next char is '~'. Error thrown and script exited.

/* -----------Walk through based on proposition 2 (all values false)--------------- */
$propositionChars	Process
	[0]					0. Character index @ 0.
	[0]					1. '~' encountered. Next char === '('. $group[1]['finalOp'] = '~'; $group[1]['evalLocation'] = 0; Next index.
	[1]					2. '(' encountered. $group[1]['start'] = 1; Next index.
	[2]					3. FALSE encountered. Next character is not BOOLEAN or '(' or '~'. Next index.
	[3]					4. '|' encountered. Previous char === FALSE. Next char === '('. $group[4]['finalOp'] = '|'; Next index.
	[4]					5. '(' encountered. $group[4]['start'] = 4; Next index.
	[5]					6. FALSE encountered. Next character is not BOOLEAN or '(' or '~'. Next index.
	[6]					7. '^' encountered. Previous char === FALSE. Next char is '('. $group[7]['finalOp'] = '^'; Next index.
	[7]					8. '(' encountered. $group[7]['start'] = 7; Next index.
	[8]					9. '~' encountered. Next char === FALSE. $evaluated[8] = !FALSE; Next index.
	[9]					10. FALSE encountered. Next character is not BOOLEAN or '(' or '~'. Next index.
	[10]				11. ')' encountered. end($group); $group[key($group)]['end'] = 11;